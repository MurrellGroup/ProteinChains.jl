var documenterSearchIndex = {"docs":
[{"location":"generated/examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"generated/examples/#ProteinStructure-and-ProteinChain","page":"Examples","title":"ProteinStructure and ProteinChain","text":"using ProteinChains\n\nFetch a structure from the PDB:\n\nstructure = pdb\"3NIR\"\n\npropertynames(structure)\n\nWe can index by chain ID or by index:\n\nchain = structure[\"A\"]\n\nchain == structure[1]\n\nA chain has a few basic fields:\n\npropertynames(chain)\n\nchain.id\n\ntypeof(chain.atoms)\n\nchain.sequence\n\nchain.numbering\n\nchain.ins_codes # (sometimes just a string of spaces)\n\nThe atoms field is a residue-wise vector of vectors of Atoms, but often we just want the backbone:\n\nget_backbone(chain)\n\nChains can be indexed/reordered with a vector of residue indices:\n\nchain[1:10].numbering\n\nchain[10:-1:1].numbering","category":"section"},{"location":"generated/examples/#Dynamic-properties","page":"Examples","title":"Dynamic properties","text":"The chain type is dynamic, so we can add new properties dynamically at runtime:\n\nchain.taxonomy_id = 3721;\nnothing #hide\n\nchain.taxonomy_id\n\ndelete!(chain, :taxonomy_id);\nnothing #hide\n\nhasproperty(chain, :taxonomy_id)\n\nFor a property whose last dimension is tied to the number of residues, we can wrap it with Indexable to automatically index it when we index the chain:\n\nchain.confidence = Indexable(rand(length(chain)));\nnothing #hide\n\nchain[1:10].confidence # still wrapped by Indexable\n\nunwrap(chain[1:10].confidence)","category":"section"},{"location":"generated/examples/#Backbone-geometry","page":"Examples","title":"Backbone geometry","text":"There are utility functions for getting the backbone geometry:\n\nget_bond_lengths(chain) # N₁-Ca₁, Ca₁-C₁, C₁-N₂, N₂-Ca₂, ... Caₙ-Cₙ\n\nget_bond_angles(chain) # N₁-Ca₁-C₁, Ca₁-C₁-N₂, C₁-N₂-Ca₂, ... Cₙ-Caₙ-Cₙ\n\nget_torsion_angles(chain) # N₁-Ca₁-C₁-N₂, Ca₁-C₁-N₂-Ca₂, C₁-N₂-Ca₂-C₂, ... Cₙ₋₁-Nₙ-Caₙ-Cₙ\n\nThere are also functions for getting the residue-wise rigid transformation \"frames\" of the chain:\n\nframes = Frames(chain);\nnothing #hide\n\nsize(frames.rotations)\n\nsize(frames.translations)","category":"section"},{"location":"generated/examples/#MMCIF-utilities","page":"Examples","title":"MMCIF utilities","text":"MMCIF files contain a lot of information that is not present in PDB files. The mapmmcif function can be used to map one MMCIF field to another.\n\nmmcifdict = mmcifdict\"3HFM\";\nnothing #hide\n\nmapmmcif(mmcifdict, \"_atom_site.auth_asym_id\"   => \"_atom_site.label_entity_id\")\n\nmapmmcif(mmcifdict, \"_entity_src_gen.entity_id\" => \"_entity_src_gen.pdbx_gene_src_ncbi_taxonomy_id\")\n\nchainid_to_taxonomyid = mapmmcif(mmcifdict,\n    \"_atom_site.auth_asym_id\"   => \"_atom_site.label_entity_id\",\n    \"_entity_src_gen.entity_id\" => \"_entity_src_gen.pdbx_gene_src_ncbi_taxonomy_id\")\n\nstructure = pdb\"3HFM\"\nfor chain in structure\n    chain.taxonomy_id = chainid_to_taxonomyid[chain.id]\n    println(\"Set taxonomy_id of chain $(chain.id) to $(chain.taxonomy_id)\")\nend","category":"section"},{"location":"generated/examples/#ProteinStructureStore","page":"Examples","title":"ProteinStructureStore","text":"The ProteinStructureStore <: AbstractDict{String, ProteinStructure} type is a lazy wrapper for a file-based storage of ProteinStructures.\n\ndir = mktempdir();\nstore = ProteinStructureStore(joinpath(dir, \"structures.pss\"));\nnothing #hide\n\nstore[\"3NIR\"] = pdb\"3NIR\";\nnothing #hide\n\nstore[\"3NIR\"]\n\nstore[\"3NIR\"][\"A\"]\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"#ProteinChains","page":"Home","title":"ProteinChains","text":"Documentation for ProteinChains.\n\n","category":"section"},{"location":"#ProteinChains.STANDARD_RESIDUE_TEMPLATE","page":"Home","title":"ProteinChains.STANDARD_RESIDUE_TEMPLATE","text":"STANDARD_RESIDUE_TEMPLATE\n\nThis is a template of a \"standard residue\", with a very specific and distinct shape, size, and orientation. which needs to be consistent if we want to represent protein structures as sets of residue rotations and translations.\n\nThus, we can use this residue as a template for aligning other residues with very precise geometry to it.\n\njulia> IdealResidue{Float64}(BackboneGeometry(N_Ca_C_angle = 1.93); template=ProteinChains.STANDARD_RESIDUE_TEMPLATE)\n3×3 IdealResidue{Float64}:\n -1.06447   -0.199174   1.26364\n  0.646303  -0.529648  -0.116655\n  0.0        0.0        0.0\n\n\n\n\n\n","category":"constant"},{"location":"#ProteinChains.BackboneGeometry","page":"Home","title":"ProteinChains.BackboneGeometry","text":"BackboneGeometry(;\n    N_Ca_length = 1.46,\n    Ca_C_length = 1.52,\n    C_N_length = 1.33,\n\n    N_Ca_C_angle = 1.94,\n    Ca_C_N_angle = 2.03,\n    C_N_Ca_angle = 2.13,\n)\n\nDefine the idealized bond lengths and bond angles of a protein backbone.\n\n\n\n\n\n","category":"type"},{"location":"#ProteinChains.IdealResidue","page":"Home","title":"ProteinChains.IdealResidue","text":"IdealResidue{T<:AbstractFloat} <: AbstractMatrix{T}\n\nIdealResidue{T}(backbone_geometry=DEFAULT_BACKBONE_GEOMETRY; template=nothing) where T\n\nA 3x3 matrix representing the idealized geometry of a protein residue, with columns representing the N, Ca, and C atom positions of a residue positioned at the origin.\n\n\n\n\n\n","category":"type"},{"location":"#ProteinChains.ProteinChain","page":"Home","title":"ProteinChains.ProteinChain","text":"ProteinChain{T<:Real}\n\nRepresents a protein chain with a basic set of fields from which some other properties might be derived.\n\n\n\n\n\n","category":"type"},{"location":"#ProteinChains.ProteinStructure","page":"Home","title":"ProteinChains.ProteinStructure","text":"ProteinStructure{T} <: AbstractVector{ProteinChain{T}}\n\nFields\n\nname::String: Usually just the base name of the original file.\nchains::Vector{ProteinChain{T}}: a collection of ProteinChains.\natoms::Vector{Atom{T}}: free atoms from the structure that were not part of any protein residue.\n\n\n\n\n\n","category":"type"},{"location":"#ProteinChains.ProteinStructureStore","page":"Home","title":"ProteinChains.ProteinStructureStore","text":"ProteinStructureStore <: AbstractDict{InlineStrings.String31,ProteinStructure}\n\nA JLD2-based store for protein structures implementing the AbstractDict interface, allowing for dictionary operations on the stored structures.\n\nKeys are stored as InlineStrings.String31 objects to reduce references. This means keys are limited to 31 bytes.\n\nA ProteinStructureStore gets closed automatically when there no longer exists a program-accessible reference to it.\n\nExamples\n\njulia> store = ProteinStructureStore(\"store.pss\")\nProteinStructureStore with 0 entries\n\njulia> store[\"3HFM\"] = pdb\"3HFM\"\n[ Info: Downloading file from PDB: 3HFM\n3-element ProteinStructure \"3HFM.cif\":\n 215-residue ProteinChain{Float64} (H)\n 214-residue ProteinChain{Float64} (L)\n 129-residue ProteinChain{Float64} (Y)\n\njulia> store\nProteinStructureStore with 1 entry\n\njulia> keys(store)\nSet{InlineStrings.String31} with 1 element:\n  InlineStrings.String31(\"3HFM\")\n\njulia> delete!(store, \"3HFM\")\nProteinStructureStore with 0 entries\n\n\n\n\n\n","category":"type"},{"location":"#ProteinChains.ProteinStructureStore-Tuple{Function, Vararg{Any}}","page":"Home","title":"ProteinChains.ProteinStructureStore","text":"ProteinStructureStore(f::Function, filename, mode=\"a+\")\n\n\n\n\n\n","category":"method"},{"location":"#ProteinChains.all_atom_coords-Tuple{Any}","page":"Home","title":"ProteinChains.all_atom_coords","text":"all_atom_coords(chain)\n\nReturn a 3 × N matrix of all-atom Cartesian coordinates for a ProteinChain. This is written to be type-stable and allocation-friendly.\n\n\n\n\n\n","category":"method"},{"location":"#ProteinChains.append_residue-Tuple{Backbone, Vector{<:Real}}","page":"Home","title":"ProteinChains.append_residue","text":"append_residue(Backbone::Backbone, torsion_angles::Vector{<:Real}; ideal::BackboneGeometry=DEFAULT_BACKBONE_GEOMETRY)\n\nCreate a new backbone by appending 3 new torsion angles (ψ, ω, ϕ) at the end, using bond lengths and bond angles specified in BackboneGeometry.\n\n\n\n\n\n","category":"method"},{"location":"#ProteinChains.atom_contact_order-Tuple{ProteinChain}","page":"Home","title":"ProteinChains.atom_contact_order","text":"atom_contact_order(chain; cutoff = 6.0)\n\nAtom-level contact order (ALCO) matching the definition in Eric Alm's contactOrder.pl script.\n\nFor a single chain:\n\nconsider all non-hydrogen atoms,\nfor each contacting atom pair within cutoff Å, with positive sequence separation in chain.numbering, accumulate that separation;\nthe absolute CO is order / counts;\nthe relative CO is absolute_CO / (max(numbering) - min(numbering) + 1).\n\nResults should match Plaxco et al. 1998, Table 1.\n\n\n\n\n\n","category":"method"},{"location":"#ProteinChains.cysteine_features-Tuple{Any}","page":"Home","title":"ProteinChains.cysteine_features","text":"cysteine_features(structure; distance_cutoff = 2.5)\n\nFor each chain, count:\n\nnum_paired::Int: number of cysteines that participate in a disulfide bond (including those paired with cysteines in other chains),\nnum_cys::Int: total number of cysteines in the chain.\n\nPairing is defined by SG–SG distances < distance_cutoff Å, including pairs between different chains. Returns a vector of named tuples, one per chain.\n\n\n\n\n\n","category":"method"},{"location":"#ProteinChains.deserialize-Tuple{AbstractString}","page":"Home","title":"ProteinChains.deserialize","text":"deserialize(filename::AbstractString)\n\nDeserialize ProteinStructure objects from a JLD2 file. Returns a Vector{ProteinStructure} of all structures stored in the file.\n\n\n\n\n\n","category":"method"},{"location":"#ProteinChains.interchain_atom_contact_proportion-Tuple{Any}","page":"Home","title":"ProteinChains.interchain_atom_contact_proportion","text":"interchain_atom_contact_proportion(structure; distance_cutoff = 5.0)\n\nAtom-level inter-chain contact proportion: for each chain, returns the fraction of atoms that are within distance_cutoff Å of at least one atom in another chain.\n\nResults should match Plaxco et al. 1998, Table 1.\n\n\n\n\n\n","category":"method"},{"location":"#ProteinChains.interchain_contact_counts-Tuple{Any}","page":"Home","title":"ProteinChains.interchain_contact_counts","text":"interchain_contact_counts(structure; distance_cutoff = 5.0)\n\nFor each chain, count how many residues make contact with at least one residue in any other chain, based on all-atom contacts with a distance cutoff distance_cutoff (Å).\n\nReturns a vector of integers, one per chain.\n\n\n\n\n\n","category":"method"},{"location":"#ProteinChains.interchain_residue_contact_proportion-Tuple{Any}","page":"Home","title":"ProteinChains.interchain_residue_contact_proportion","text":"interchain_residue_contact_proportion(structure; distance_cutoff = 5.0)\n\nResidue-level inter-chain contact proportion: for each chain, returns the fraction of residues that have at least one atom within distance_cutoff Å of any atom in another chain.\n\n\n\n\n\n","category":"method"},{"location":"#ProteinChains.mapmmcif-Tuple{Any, Vararg{Pair{String, String}}}","page":"Home","title":"ProteinChains.mapmmcif","text":"mapmmcif(mmcifdict, field1 => field2, field3 => field4, ...)\n\njulia> import BioStructures\n\njulia> filename = BioStructures.downloadpdb(\"3HFM\", format=BioStructures.MMCIFFormat);\n[ Info: Downloading file from PDB: 3HFM\n\njulia> mmcifdict = BioStructures.MMCIFDict(filename);\n\njulia> mapmmcif(mmcifdict,\n           \"_atom_site.auth_asym_id\"   => \"_atom_site.label_entity_id\",\n           \"_entity_src_gen.entity_id\" => \"_entity_src_gen.pdbx_gene_src_ncbi_taxonomy_id\")\nDict{String, String} with 3 entries:\n  \"Y\" => \"9031\"\n  \"L\" => \"10090\"\n  \"H\" => \"10090\"\n\n\n\n\n\n","category":"method"},{"location":"#ProteinChains.pdbentry-Tuple{AbstractString}","page":"Home","title":"ProteinChains.pdbentry","text":"pdbentry(pdbid::AbstractString; format=MMCIFFormat, kws...)\n\nKeyword arguments get propagated to BioStructures.downloadpdb\n\nDownloads are cached in a temporary directory.\n\nExamples\n\njulia> pdbentry(\"1EYE\")\n[ Info: Downloading file from PDB: 1EYE\n1-element ProteinStructure \"1EYE.cif\":\n 256-residue ProteinChain{Float64} (A)\n\njulia> pdb\"1EYE\" # string macro for convenience\n[ Info: File exists: 1EYE\n1-element ProteinStructure \"1EYE.cif\":\n 256-residue ProteinChain{Float64} (A)\n\njulia> pdb\"1EYE\"A # string suffix to get a specific chain\n[ Info: File exists: 1EYE\n256-residue ProteinChain{Float64} (A)\n\njulia> pdb\"1EYE\"1 # integer suffix to specify \"ba_number\" keyword\n[ Info: Downloading file from PDB: 1EYE\n2-element ProteinStructure \"1EYE_ba1.cif\":\n 256-residue ProteinChain{Float64} (A)\n 256-residue ProteinChain{Float64} (A-2)\n\n\n\n\n\n","category":"method"},{"location":"#ProteinChains.prepend_residue-Tuple{Backbone, Vector{<:Real}}","page":"Home","title":"ProteinChains.prepend_residue","text":"append_residue(Backbone::Backbone, torsion_angles::Vector{<:Real}; ideal::BackboneGeometry=DEFAULT_BACKBONE_GEOMETRY)\n\nCreate a new backbone by prepending 3 new torsion angles (ψ, ω, ϕ) at the beginning, using bond lengths and bond angles specified in the BackboneGeometry.\n\nnote: Note\nThe torsion angle order is the same as it would be when appending. The order is not reversed.\n\n\n\n\n\n","category":"method"},{"location":"#ProteinChains.residue_contact_order-Tuple{ProteinChain}","page":"Home","title":"ProteinChains.residue_contact_order","text":"residue_contact_order(chain; distance_thresholds = (6.0, 8.0, 10.0))\n\nCompute length-normalized contact order for a single chain, using all-atom contacts.\n\nFor each distance threshold d, contacts are residue pairs with any inter-atomic distance < d Å, excluding pairs with sequence-number separation ≤ 1 based on chain.numbering.\n\nContact order is defined as\n\nCO = (1 / (N * Leff)) * sum{(i,j) in C} |numbering[j] - numbering[i]|\n\nwhere L_eff is maximum(numbering) - minimum(numbering) + 1 and N is the number of contacts at that threshold.\n\n\n\n\n\n","category":"method"},{"location":"#ProteinChains.residue_pair_min_distances-Tuple{ProteinChain}","page":"Home","title":"ProteinChains.residue_pair_min_distances","text":"residue_pair_min_distances(chain; max_distance; use_numbering = false)\n\nCompute the minimum all-atom distance for each residue pair in chain whose minimum inter-atomic distance is ≤ max_distance, using a KDTree over all atoms. Returns a Dict{Tuple{Int,Int},Float64} mapping an ordered residue identifier pair (i, j) with i < j to the minimum distance in Å.\n\nIf use_numbering == false (default), the residue identifiers are 1-based indices into the chain (i.e. positions in chain.atoms). If use_numbering == true, the identifiers are taken from chain.numbering.\n\n\n\n\n\n","category":"method"},{"location":"#ProteinChains.serialize-Tuple{AbstractString, AbstractVector{<:ProteinStructure}}","page":"Home","title":"ProteinChains.serialize","text":"serialize(filename::AbstractString, structures::AbstractVector{<:ProteinStructure})\n\nSerialize a vector of ProteinStructure objects to a JLD2 file. This function creates a new ProteinStructureStore and writes each structure in the input vector to it. Each structure is stored using its name as the key.\n\n\n\n\n\n","category":"method"},{"location":"#ProteinChains.shape_features-Tuple{ProteinChain}","page":"Home","title":"ProteinChains.shape_features","text":"shape_features(chain)\n\nFor a single ProteinChain, return a named tuple with:\n\nradius_of_gyration: standard R_g based on all atoms;\nmean_pairwise_distance: mean distance between all atom pairs;\nmax_pairwise_distance: maximum distance between any two atoms.\n\n\n\n\n\n","category":"method"},{"location":"#ProteinChains.structure_atom_coords-Tuple{Any}","page":"Home","title":"ProteinChains.structure_atom_coords","text":"structure_atom_coords(structure)\n\nFlatten all atoms from all chains in structure into a single coordinate matrix and parallel vectors giving the chain index and residue index for each atom.\n\n\n\n\n\n","category":"method"}]
}
